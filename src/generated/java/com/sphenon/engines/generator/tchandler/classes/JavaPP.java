/* Generated By:JavaCC: Do not edit this line. JavaPP.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.engines.generator.tchandler.classes;

import com.sphenon.basics.context.*;
import com.sphenon.engines.generator.*;
import com.sphenon.engines.generator.tom.*;
import com.sphenon.engines.generator.returncodes.*;
import com.sphenon.engines.generator.tchandler.*;

import java.io.Reader;
import java.io.Writer;
import java.io.IOException;

import java.util.Vector;

public class JavaPP implements JavaPPConstants {

  protected Writer    out;
  protected TCHJavaPP tch;

  public JavaPP (CallContext context, Reader in, TCHJavaPP tch) {
      this(in);
      this.out = out;
      this.tch = tch;
  }

  public String getPosition(CallContext context) {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public TOMNode Block(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                             Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      token = jj_consume_token(OPPAR);
                          value.append(token.image);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case LOCATORB:
        case EXPRB:
        case JOIN:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case TIME:
        case FORMAT:
        case SIZE:
        case AVERAGE:
        case PRODUCT:
        case SUM:
        case MINIMUM:
        case MAXIMUM:
        case REVERSE:
        case PPKEYWORD:
        case PPKEYWORDD:
        case PPKEYWORDC:
        case PPKEYWORDCD:
        case ANY:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        current_node = JavaCodeBalanced(context, event, current_node, value, false);
      }
      token = jj_consume_token(CLPAR);
                          value.append(token.image);
      break;
    case OPBRC:
      token = jj_consume_token(OPBRC);
                          value.append(token.image);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case LOCATORB:
        case EXPRB:
        case JOIN:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case TIME:
        case FORMAT:
        case SIZE:
        case AVERAGE:
        case PRODUCT:
        case SUM:
        case MINIMUM:
        case MAXIMUM:
        case REVERSE:
        case PPKEYWORD:
        case PPKEYWORDD:
        case PPKEYWORDC:
        case PPKEYWORDCD:
        case ANY:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        current_node = JavaCodeBalanced(context, event, current_node, value, false);
      }
      token = jj_consume_token(CLBRC);
                          value.append(token.image);
      break;
    case OPBRK:
      token = jj_consume_token(OPBRK);
                          value.append(token.image);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case LOCATORB:
        case EXPRB:
        case JOIN:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case TIME:
        case FORMAT:
        case SIZE:
        case AVERAGE:
        case PRODUCT:
        case SUM:
        case MINIMUM:
        case MAXIMUM:
        case REVERSE:
        case PPKEYWORD:
        case PPKEYWORDD:
        case PPKEYWORDC:
        case PPKEYWORDCD:
        case ANY:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_3;
        }
        current_node = JavaCodeBalanced(context, event, current_node, value, false);
      }
      token = jj_consume_token(CLBRK);
                          value.append(token.image);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode ParTokens(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException {
                                                                                                    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      token = jj_consume_token(OPPAR);
                      value.append(token.image);
      break;
    case CLPAR:
      token = jj_consume_token(CLPAR);
                      value.append(token.image);
      break;
    case OPBRC:
      token = jj_consume_token(OPBRC);
                      value.append(token.image);
      break;
    case CLBRC:
      token = jj_consume_token(CLBRC);
                      value.append(token.image);
      break;
    case OPBRK:
      token = jj_consume_token(OPBRK);
                      value.append(token.image);
      break;
    case CLBRK:
      token = jj_consume_token(CLBRK);
                      value.append(token.image);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public void Tokens(StringBuffer value) throws ParseException {
                                    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
      token = jj_consume_token(CHARACTER_LITERAL);
                                  value.append(token.image);
      break;
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
                                  value.append(token.image);
      break;
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
                                  value.append(token.image);
      break;
    case WHITESPACE:
      token = jj_consume_token(WHITESPACE);
                                  value.append(token.image);
      break;
    case SLCB:
      token = jj_consume_token(SLCB);
                                  value.append(token.image);
      break;
    case SLC:
      token = jj_consume_token(SLC);
                                  value.append(token.image);
      break;
    case SLCE:
      token = jj_consume_token(SLCE);
                                  value.append(token.image);
      break;
    case MLCB:
      token = jj_consume_token(MLCB);
                                  value.append(token.image);
      break;
    case MLC:
      token = jj_consume_token(MLC);
                                  value.append(token.image);
      break;
    case MLCE:
      token = jj_consume_token(MLCE);
                                  value.append(token.image);
      break;
    case SLASH:
      token = jj_consume_token(SLASH);
                                  value.append(token.image);
      break;
    case COLON:
      token = jj_consume_token(COLON);
                                  value.append(token.image);
      break;
    case MINUS:
      token = jj_consume_token(MINUS);
                                  value.append(token.image);
      break;
    case DOT:
      token = jj_consume_token(DOT);
                                  value.append(token.image);
      break;
    case LT:
      token = jj_consume_token(LT);
                                  value.append(token.image);
      break;
    case GT:
      token = jj_consume_token(GT);
                                  value.append(token.image);
      break;
    case ANY:
      token = jj_consume_token(ANY);
                                  value.append(token.image);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AllTokens(StringBuffer value) throws ParseException {
                                       Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      token = jj_consume_token(IF);
                                  value.append(token.image);
      break;
    case WHITESPACE:
    case SLCB:
    case MLCB:
    case SLCE:
    case SLC:
    case MLCE:
    case MLC:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LT:
    case GT:
    case DOT:
    case SLASH:
    case COLON:
    case MINUS:
    case ANY:
      Tokens(value);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PlainBlock(StringBuffer value) throws ParseException {
                                        Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      token = jj_consume_token(OPPAR);
                          value.append(token.image);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case ANY:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        PlainJavaCodeBalanced(value);
      }
      token = jj_consume_token(CLPAR);
                          value.append(token.image);
      break;
    case OPBRC:
      token = jj_consume_token(OPBRC);
                          value.append(token.image);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case ANY:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_5;
        }
        PlainJavaCodeBalanced(value);
      }
      token = jj_consume_token(CLBRC);
                          value.append(token.image);
      break;
    case OPBRK:
      token = jj_consume_token(OPBRK);
                          value.append(token.image);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case ANY:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_6;
        }
        PlainJavaCodeBalanced(value);
      }
      token = jj_consume_token(CLBRK);
                          value.append(token.image);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public StringBuffer JavaType(CallContext context, StringBuffer value) throws ParseException {
                                                                   Token token;
    if (value == null) { value = new StringBuffer(); }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case OPBRK:
      case CLBRK:
      case LT:
      case DOT:
      case SLASH:
      case COLON:
      case MINUS:
      case ANY:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER_LITERAL:
        token = jj_consume_token(CHARACTER_LITERAL);
                                  value.append(token.image);
        break;
      case STRING_LITERAL:
        token = jj_consume_token(STRING_LITERAL);
                                  value.append(token.image);
        break;
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
                                  value.append(token.image);
        break;
      case DOT:
        token = jj_consume_token(DOT);
                                  value.append(token.image);
        break;
      case WHITESPACE:
        token = jj_consume_token(WHITESPACE);
                                  value.append(token.image);
        break;
      case SLASH:
        token = jj_consume_token(SLASH);
                                  value.append(token.image);
        break;
      case COLON:
        token = jj_consume_token(COLON);
                                  value.append(token.image);
        break;
      case MINUS:
        token = jj_consume_token(MINUS);
                                  value.append(token.image);
        break;
      case LT:
        token = jj_consume_token(LT);
                                    value.append(token.image);
        JavaType(context, value);
        token = jj_consume_token(GT);
                                    value.append(token.image);
        break;
      case OPBRK:
        token = jj_consume_token(OPBRK);
                                  value.append(token.image);
        break;
      case CLBRK:
        token = jj_consume_token(CLBRK);
                                  value.append(token.image);
        break;
      case ANY:
        token = jj_consume_token(ANY);
                                  value.append(token.image);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode PPOpeningKeyword(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                                         Token token; Token aliastoken=null; Token minus=null; String ppkeyword; String alias="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PPKEYWORD:
      token = jj_consume_token(PPKEYWORD);
                                     ppkeyword = token.image.substring(1);
      break;
    case PPKEYWORDD:
      token = jj_consume_token(PPKEYWORDD);
                                     ppkeyword = token.image.substring(2,token.image.length()-1);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                 if (value.length() > 0) {
                                   current_node = tch.handleCode(context, event, current_node, value.toString());
                                   value.setLength(0);
                                 }
                                 current_node =  tch.handlePPOpeningKeywordBegin(context, event, current_node, ppkeyword);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_8;
      }
      jj_consume_token(WHITESPACE);
    }
    jj_consume_token(OPPAR);
    if (jj_2_1(2147483647)) {
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_9;
        }
        jj_consume_token(WHITESPACE);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        minus = jj_consume_token(MINUS);
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WHITESPACE:
            ;
            break;
          default:
            jj_la1[16] = jj_gen;
            break label_10;
          }
          jj_consume_token(WHITESPACE);
        }
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        aliastoken = jj_consume_token(IDENTIFIER);
        label_11:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WHITESPACE:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_11;
          }
          jj_consume_token(WHITESPACE);
        }
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
                 alias = (minus == null ? "" : minus.image) + (aliastoken == null ? "" : aliastoken.image);
                 tch.handlePPOpeningKeywordAlias(context, event, current_node, ppkeyword, alias);
                 StringBuffer alias_type = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        jj_consume_token(LT);
        alias_type = JavaType(context, null);
        jj_consume_token(GT);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
                 if (alias_type != null) { tch.handlePPOpeningKeywordAliasType(context, event, current_node, ppkeyword, alias_type.toString()); }
      jj_consume_token(COLON);
    } else {
      ;
    }
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case SLCB:
      case MLCB:
      case SLCE:
      case SLC:
      case MLCE:
      case MLC:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IF:
      case IDENTIFIER:
      case LOCATORB:
      case EXPRB:
      case JOIN:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case LT:
      case GT:
      case DOT:
      case SLASH:
      case COLON:
      case COMMA:
      case MINUS:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case REVERSE:
      case PPKEYWORD:
      case PPKEYWORDD:
      case PPKEYWORDC:
      case PPKEYWORDCD:
      case ANY:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_12;
      }
      current_node = JavaCodeBalanced(context, event, current_node, value, true);
    }
    jj_consume_token(CLPAR);
                                 if (value.length() > 0) {
                                   current_node = tch.handleCode(context, event, current_node, value.toString());
                                   value.setLength(0);
                                 }
                                 current_node =  tch.handlePPOpeningKeywordEnd(context, event, current_node, ppkeyword);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode PPClosingKeyword(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                                         Token token; String ppkeyword;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PPKEYWORDC:
      token = jj_consume_token(PPKEYWORDC);
                                     ppkeyword = token.image.substring(2);
      break;
    case PPKEYWORDCD:
      token = jj_consume_token(PPKEYWORDCD);
                                     ppkeyword = token.image.substring(3,token.image.length()-1);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                 if (value.length() > 0) {
                                   current_node = tch.handleCode(context, event, current_node, value.toString());
                                   value.setLength(0);
                                 }
                                 current_node =  tch.handlePPClosingKeyword(context, event, current_node, ppkeyword);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Expression(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                                   Token token; Token cast=null;
    StringBuffer expression = new StringBuffer();
    StringBuffer arguments = null;
    jj_consume_token(EXPRB);
              if (value.length() > 0) { current_node = tch.handleCode(context, event, current_node, value.toString()); value.setLength(0); }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELT:
      jj_consume_token(ELT);
      cast = jj_consume_token(EIDENTIFIER);
      jj_consume_token(EGT);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOPBRK:
      jj_consume_token(EOPBRK);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EIDENTIFIER:
        case EANY:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_13;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EIDENTIFIER:
          token = jj_consume_token(EIDENTIFIER);
                                        arguments.append(token.image);
          break;
        case EANY:
          token = jj_consume_token(EANY);
                                        arguments.append(token.image);
          break;
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(ECLBRK);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EIDENTIFIER:
    case EANY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EIDENTIFIER:
        token = jj_consume_token(EIDENTIFIER);
                                        expression.append(token.image);
        break;
      case EANY:
        token = jj_consume_token(EANY);
                                        expression.append(token.image);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELT:
        case EGT:
        case EOPBRK:
        case ECLBRK:
        case EIDENTIFIER:
        case EANY:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_14;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELT:
          jj_consume_token(ELT);
                                        expression.append("<");
          break;
        case EGT:
          jj_consume_token(EGT);
                                        expression.append(">");
          break;
        case EOPBRK:
          jj_consume_token(EOPBRK);
                                        expression.append("[");
          break;
        case ECLBRK:
          jj_consume_token(ECLBRK);
                                        expression.append("]");
          break;
        case EIDENTIFIER:
          token = jj_consume_token(EIDENTIFIER);
                                        expression.append(token.image);
          break;
        case EANY:
          token = jj_consume_token(EANY);
                                        expression.append(token.image);
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    jj_consume_token(EXPRE);
              current_node =  tch.handleExpression(context, event, current_node, expression.toString(), (cast == null ? null : cast.image), arguments.toString());
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Locator(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                                Token token; Token cast=null; Token base=null;
    StringBuffer arguments;
    jj_consume_token(LOCATORB);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LLT:
      jj_consume_token(LLT);
      cast = jj_consume_token(LIDENTIFIER);
      jj_consume_token(LGT);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOPBRK:
      jj_consume_token(LOPBRK);
      base = jj_consume_token(LIDENTIFIER);
      jj_consume_token(LCLBRK);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DELIMLOC:
      token = jj_consume_token(DELIMLOC);
                                          if (value.length() > 0) {
                                            current_node = tch.handleCode(context, event, current_node, value.toString());
                                            value.setLength(0);
                                          }
                                          current_node =  tch.handleLocator(context, event, current_node, token.image, true, (base == null ? null : base.image), (cast == null ? null : cast.image), null);
      break;
    case DYNAMIC:
      jj_consume_token(DYNAMIC);
                                        arguments = new StringBuffer();
      token = jj_consume_token(DELIMLOC);
      jj_consume_token(OPPAR);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case ANY:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_15;
        }
        PlainJavaCodeBalanced(arguments);
      }
      jj_consume_token(CLPAR);
                                          if (value.length() > 0) {
                                            current_node = tch.handleCode(context, event, current_node, value.toString());
                                            value.setLength(0);
                                          }
                                          current_node =  tch.handleLocator(context, event, current_node, token.image, true, (base == null ? null : base.image), (cast == null ? null : cast.image), arguments.toString());
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Join(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                             Token token;
    jj_consume_token(JOIN);
                 if (value.length() > 0) {
                   current_node = tch.handleCode(context, event, current_node, value.toString());
                   value.setLength(0);
                 }
                 current_node =  tch.handleJoinBegin(context, event, current_node);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case SLCB:
      case MLCB:
      case SLCE:
      case SLC:
      case MLCE:
      case MLC:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IF:
      case IDENTIFIER:
      case LOCATORB:
      case EXPRB:
      case JOIN:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case LT:
      case GT:
      case DOT:
      case SLASH:
      case COLON:
      case COMMA:
      case MINUS:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case REVERSE:
      case PPKEYWORD:
      case PPKEYWORDD:
      case PPKEYWORDC:
      case PPKEYWORDCD:
      case ANY:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_16;
      }
      current_node = JavaCodeBalanced(context, event, current_node, value, true);
    }
    jj_consume_token(EJOIN);
                 if (value.length() > 0) {
                   current_node = tch.handleCode(context, event, current_node, value.toString());
                   value.setLength(0);
                 }
                 current_node =  tch.handleJoinEnd(context, event, current_node);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode PPKeywordFunction(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                                          Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TIME:
        if (value.length() > 0) { current_node = tch.handleCode(context, event, current_node, value.toString()); value.setLength(0); }
      jj_consume_token(TIME);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "time");
      break;
    case FORMAT:
      jj_consume_token(FORMAT);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "format");
      break;
    case SIZE:
      jj_consume_token(SIZE);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "size");
      break;
    case AVERAGE:
      jj_consume_token(AVERAGE);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "average");
      break;
    case PRODUCT:
      jj_consume_token(PRODUCT);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "product");
      break;
    case SUM:
      jj_consume_token(SUM);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "sum");
      break;
    case MINIMUM:
      jj_consume_token(MINIMUM);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "minimum");
      break;
    case MAXIMUM:
      jj_consume_token(MAXIMUM);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "maximum");
      break;
    case REVERSE:
      jj_consume_token(REVERSE);
                     current_node =  tch.handleKeywordFunction(context, event, current_node, "reverse");
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode JavaCodeBalanced(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value, boolean toplevel) throws ParseException, InvalidTemplateSyntax {
                                                                                                                                                           Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
    case OPBRC:
    case OPBRK:
      Block(context, event, current_node, value);
      break;
    case LOCATORB:
      current_node = Locator(context, event, current_node, value);
      break;
    case EXPRB:
      current_node = Expression(context, event, current_node, value);
      break;
    case JOIN:
      Join(context, event, current_node, value);
      break;
    case TIME:
    case FORMAT:
    case SIZE:
    case AVERAGE:
    case PRODUCT:
    case SUM:
    case MINIMUM:
    case MAXIMUM:
    case REVERSE:
      PPKeywordFunction(context, event, current_node, value);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case LOCATORB:
        case EXPRB:
        case JOIN:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case TIME:
        case FORMAT:
        case SIZE:
        case AVERAGE:
        case PRODUCT:
        case SUM:
        case MINIMUM:
        case MAXIMUM:
        case REVERSE:
        case PPKEYWORD:
        case PPKEYWORDD:
        case PPKEYWORDC:
        case PPKEYWORDCD:
        case ANY:
          ;
          break;
        default:
          jj_la1[37] = jj_gen;
          break label_17;
        }
        current_node = JavaCodeBalanced(context, event, current_node, value, false);
      }
      token = jj_consume_token(CLPAR);
                          value.append(token.image);
      break;
    case PPKEYWORD:
    case PPKEYWORDD:
      PPOpeningKeyword(context, event, current_node, value);
      break;
    case PPKEYWORDC:
    case PPKEYWORDCD:
      PPClosingKeyword(context, event, current_node, value);
      break;
    case IF:
      If(context, event, current_node, value);
      break;
    case WHITESPACE:
    case SLCB:
    case MLCB:
    case SLCE:
    case SLC:
    case MLCE:
    case MLC:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LT:
    case GT:
    case DOT:
    case SLASH:
    case COLON:
    case MINUS:
    case ANY:
      Tokens(value);
      break;
    case COMMA:
      token = jj_consume_token(COMMA);
                      if (toplevel) {
                        if (value.length() > 0) {
                          current_node = tch.handleCode(context, event, current_node, value.toString());
                          value.setLength(0);
                        }
                        current_node = tch.handleComma(context, event, current_node, token.image);
                      } else {
                        value.append(token.image);
                      }
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public void PlainJavaCodeBalanced(StringBuffer value) throws ParseException {
                                                   Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
    case OPBRC:
    case OPBRK:
      PlainBlock(value);
      break;
    case WHITESPACE:
    case SLCB:
    case MLCB:
    case SLCE:
    case SLC:
    case MLCE:
    case MLC:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IF:
    case IDENTIFIER:
    case LT:
    case GT:
    case DOT:
    case SLASH:
    case COLON:
    case MINUS:
    case ANY:
      AllTokens(value);
      break;
    case COMMA:
      token = jj_consume_token(COMMA);
                      value.append(token.image);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public TOMNode If(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                           Token token; Token aliastoken=null; Token minus=null; String ppkeyword; String alias="";
    jj_consume_token(IF);
                                 if (value.length() > 0) {
                                   current_node = tch.handleCode(context, event, current_node, value.toString());
                                   value.setLength(0);
                                 }
                                 current_node =  tch.handleIfBegin(context, event, current_node);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_18;
      }
      jj_consume_token(WHITESPACE);
    }
    jj_consume_token(OPPAR);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case SLCB:
      case MLCB:
      case SLCE:
      case SLC:
      case MLCE:
      case MLC:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IF:
      case IDENTIFIER:
      case LOCATORB:
      case EXPRB:
      case JOIN:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case LT:
      case GT:
      case DOT:
      case SLASH:
      case COLON:
      case COMMA:
      case MINUS:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case REVERSE:
      case PPKEYWORD:
      case PPKEYWORDD:
      case PPKEYWORDC:
      case PPKEYWORDCD:
      case ANY:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_19;
      }
      current_node = JavaCodeBalanced(context, event, current_node, value, true);
    }
    jj_consume_token(CLPAR);
                                 if (value.length() > 0) {
                                   current_node = tch.handleCode(context, event, current_node, value.toString());
                                   value.setLength(0);
                                 }
                                 current_node =  tch.handleIfEnd(context, event, current_node);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode JavaCode(CallContext context, TCEvent event, TOMNode current_node, StringBuffer value) throws ParseException, InvalidTemplateSyntax {
                                                                                                                                 Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
    case CLPAR:
    case OPBRC:
    case CLBRC:
    case OPBRK:
    case CLBRK:
      current_node = ParTokens(context, event, current_node, value);
      break;
    case LOCATORB:
      current_node = Locator(context, event, current_node, value);
      break;
    case JOIN:
      Join(context, event, current_node, value);
      break;
    case TIME:
    case FORMAT:
    case SIZE:
    case AVERAGE:
    case PRODUCT:
    case SUM:
    case MINIMUM:
    case MAXIMUM:
    case REVERSE:
      PPKeywordFunction(context, event, current_node, value);
      break;
    case PPKEYWORD:
    case PPKEYWORDD:
      PPOpeningKeyword(context, event, current_node, value);
      break;
    case PPKEYWORDC:
    case PPKEYWORDCD:
      PPClosingKeyword(context, event, current_node, value);
      break;
    case IF:
      If(context, event, current_node, value);
      break;
    case WHITESPACE:
    case SLCB:
    case MLCB:
    case SLCE:
    case SLC:
    case MLCE:
    case MLC:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LT:
    case GT:
    case DOT:
    case SLASH:
    case COLON:
    case MINUS:
    case ANY:
      Tokens(value);
      break;
    case COMMA:
      token = jj_consume_token(COMMA);
                      value.append(token.image);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public Vector Recoding(Vector recoding) throws ParseException {
                                     Token reco = null; StringBuffer value;
    value = new StringBuffer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      reco = jj_consume_token(IDENTIFIER);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[43] = jj_gen;
          break label_20;
        }
        jj_consume_token(WHITESPACE);
      }
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      jj_consume_token(OPPAR);
      label_21:
      while (true) {
        PlainJavaCodeBalanced(value);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
        case SLCB:
        case MLCB:
        case SLCE:
        case SLC:
        case MLCE:
        case MLC:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IF:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case DOT:
        case SLASH:
        case COLON:
        case COMMA:
        case MINUS:
        case ANY:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_21;
        }
      }
      jj_consume_token(CLPAR);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[46] = jj_gen;
          break label_22;
        }
        jj_consume_token(WHITESPACE);
      }
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
      if (recoding == null) { recoding = new Vector(); }
      String[] recoentry = new String[2];
      recoentry[0] = (reco == null ? null : reco.image);
      recoentry[1] = value.toString();
      recoding.add(recoentry);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH:
    case COMMA:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH:
        jj_consume_token(SLASH);
        label_23:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WHITESPACE:
            ;
            break;
          default:
            jj_la1[48] = jj_gen;
            break label_23;
          }
          jj_consume_token(WHITESPACE);
        }
        recoding = Recoding(recoding);
        break;
      case COMMA:
        jj_consume_token(COMMA);
        label_24:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WHITESPACE:
            ;
            break;
          default:
            jj_la1[49] = jj_gen;
            break label_24;
          }
          jj_consume_token(WHITESPACE);
        }
                                      recoding.add(null);
        recoding = Recoding(recoding);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    {if (true) return recoding;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Java(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                         Token token; StringBuffer value; Token slash=null; Vector recoding=null;
    value = new StringBuffer();
    current_node = tch.beginHandling(context, event, current_node);
    label_25:
    while (true) {
      current_node = JavaCode(context, event, current_node, value);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case SLCB:
      case MLCB:
      case SLCE:
      case SLC:
      case MLCE:
      case MLC:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IF:
      case IDENTIFIER:
      case LOCATORB:
      case JOIN:
      case OPPAR:
      case CLPAR:
      case OPBRC:
      case CLBRC:
      case OPBRK:
      case CLBRK:
      case LT:
      case GT:
      case DOT:
      case SLASH:
      case COLON:
      case COMMA:
      case MINUS:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case REVERSE:
      case PPKEYWORD:
      case PPKEYWORDD:
      case PPKEYWORDC:
      case PPKEYWORDCD:
      case ANY:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_25;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RECODING:
      jj_consume_token(RECODING);
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          ;
          break;
        default:
          jj_la1[53] = jj_gen;
          break label_26;
        }
        jj_consume_token(WHITESPACE);
      }
      recoding = Recoding(null);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    jj_consume_token(0);
    if (value.length() > 0) {
      current_node = tch.handleCode(context, event, current_node, value.toString());
    }
    current_node = tch.endHandling(context, event, current_node, recoding);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_3_1() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(29)) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(11)) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) return true;
    }
    return false;
  }

  public JavaPPTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[55];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xffaabffe,0xffaabffe,0xffaabffe,0x2a0000,0x7e0000,0x2f800bfe,0x2f800ffe,0x3faa0ffe,0x3faa0ffe,0x3faa0ffe,0x2a0000,0x2ee00b02,0x2ee00b02,0x0,0x2,0x2,0x2,0x20000000,0x2,0x800,0x800000,0xffaabffe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3faa0ffe,0x0,0xffaabffe,0xc0000000,0xffaabffe,0xffaabffe,0x3faa0ffe,0x2,0xffaabffe,0xfffe9ffe,0x2,0x800,0x3faa0ffe,0x2,0x20000,0x2,0x2,0x14000000,0x14000000,0xfffe9ffe,0x2,0x4000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0xfff,0xfff,0xfff,0x0,0x0,0x800,0x800,0x800,0x800,0x800,0x0,0x800,0x800,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff,0x600,0x200000,0x14000000,0x14000000,0x800000,0x14000000,0x15e00000,0x15e00000,0x14000000,0x4000,0x1000,0x800,0x180000,0xfff,0x7f,0xfff,0xfff,0x800,0x0,0xfff,0xfff,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0xfff,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public JavaPP(java.io.InputStream stream) {
     this(stream, null);
  }
  public JavaPP(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JavaPPTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public JavaPP(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new JavaPPTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public JavaPP(JavaPPTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(JavaPPTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 55; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[61];
    for (int i = 0; i < 61; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 55; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 61; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
