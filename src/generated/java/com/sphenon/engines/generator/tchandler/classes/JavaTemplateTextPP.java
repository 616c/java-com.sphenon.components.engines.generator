/* Generated By:JavaCC: Do not edit this line. JavaTemplateTextPP.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.engines.generator.tchandler.classes;

import com.sphenon.basics.context.*;
import com.sphenon.engines.generator.*;
import com.sphenon.engines.generator.tom.*;
import com.sphenon.engines.generator.returncodes.*;
import com.sphenon.engines.generator.tchandler.*;

import java.io.Reader;
import java.io.Writer;
import java.io.IOException;

public class JavaTemplateTextPP implements JavaTemplateTextPPConstants {

  protected Writer    out;
  protected TCHJavaTemplateTextPP tch;

  public JavaTemplateTextPP (CallContext context, Reader in, TCHJavaTemplateTextPP tch) {
      this(in);
      this.out = out;
      this.tch = tch;
  }

  public String getPosition(CallContext context) {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public Token AnyIdentifier() throws ParseException {
                          Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
      break;
    case TEMPLATE:
      token = jj_consume_token(TEMPLATE);
      break;
    case REQUIRES:
      token = jj_consume_token(REQUIRES);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final public String DotIdentifier() throws ParseException {
                           Token token; String result; String postfix;
    postfix = "";
    jj_consume_token(DOT);
    token = AnyIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      postfix = DotIdentifier();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
                                                                 result = "." + token.image + postfix;
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String DottedIdentifier() throws ParseException {
                              Token token; String result; String postfix;
    postfix = "";
    token = AnyIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      postfix = DotIdentifier();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
                                                           result = token.image + postfix;
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void WSNL() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      case NL:
        jj_consume_token(NL);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_1;
      }
    }
  }

  final public String DefaultValue() throws ParseException {
                           Token token; StringBuffer value;
    value = new StringBuffer();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
        token = jj_consume_token(TEMPLATE);
                            value.append(token.image);
        break;
      case REQUIRES:
        token = jj_consume_token(REQUIRES);
                            value.append(token.image);
        break;
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
                            value.append(token.image);
        break;
      case LT:
        token = jj_consume_token(LT);
                            value.append(token.image);
        break;
      case GT:
        token = jj_consume_token(GT);
                            value.append(token.image);
        break;
      case DOT:
        token = jj_consume_token(DOT);
                            value.append(token.image);
        break;
      case WS:
        token = jj_consume_token(WS);
                            value.append(token.image);
        break;
      case NL:
        token = jj_consume_token(NL);
                            value.append(token.image);
        break;
      case EQ:
        token = jj_consume_token(EQ);
                            value.append(token.image);
        break;
      case AT2:
        token = jj_consume_token(AT2);
                            value.append(token.image);
        break;
      case DSHCLO:
        token = jj_consume_token(DSHCLO);
                            value.append("->");
        break;
      case OPEDSH:
        token = jj_consume_token(OPEDSH);
                            value.append("<-");
        break;
      case EQUCLO:
        token = jj_consume_token(EQUCLO);
                            value.append("=>");
        break;
      case OPEEQU:
        token = jj_consume_token(OPEEQU);
                            value.append("<=");
        break;
      case ANY:
        token = jj_consume_token(ANY);
                            value.append(token.image);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
      case REQUIRES:
      case IDENTIFIER:
      case DSHCLO:
      case OPEDSH:
      case EQUCLO:
      case OPEEQU:
      case LT:
      case GT:
      case DOT:
      case EQ:
      case AT2:
      case WS:
      case NL:
      case ANY:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_2;
      }
    }
    {if (true) return value.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String AnyButAT() throws ParseException {
                      Token token; StringBuffer value;
    value = new StringBuffer();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
        token = jj_consume_token(TEMPLATE);
                            value.append(token.image);
        break;
      case REQUIRES:
        token = jj_consume_token(REQUIRES);
                            value.append(token.image);
        break;
      case IDENTIFIER:
        token = jj_consume_token(IDENTIFIER);
                            value.append(token.image);
        break;
      case OPTPL:
        token = jj_consume_token(OPTPL);
                            value.append(token.image);
        break;
      case CLTPL:
        token = jj_consume_token(CLTPL);
                            value.append(token.image);
        break;
      case LT:
        token = jj_consume_token(LT);
                            value.append(token.image);
        break;
      case GT:
        token = jj_consume_token(GT);
                            value.append(token.image);
        break;
      case COMMA:
        token = jj_consume_token(COMMA);
                            value.append(token.image);
        break;
      case DOT:
        token = jj_consume_token(DOT);
                            value.append(token.image);
        break;
      case EQ:
        token = jj_consume_token(EQ);
                            value.append(token.image);
        break;
      case WS:
        token = jj_consume_token(WS);
                            value.append(token.image);
        break;
      case NL:
        token = jj_consume_token(NL);
                            value.append(token.image);
        break;
      case ANY:
        token = jj_consume_token(ANY);
                            value.append(token.image);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
      case REQUIRES:
      case IDENTIFIER:
      case OPTPL:
      case CLTPL:
      case LT:
      case GT:
      case COMMA:
      case DOT:
      case EQ:
      case WS:
      case NL:
      case ANY:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
    }
    {if (true) return value.toString();}
    throw new Error("Missing return statement in function");
  }

  final public JTENodeArgument JavaTemplateFormalArgument(CallContext context) throws ParseException {
                                                                     Token token; String dotted; JTENodeArgumentList parameter = null; String default_value=null;
    dotted = DottedIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NL:
      WSNL();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPTPL:
      jj_consume_token(OPTPL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      parameter = JavaTemplateFormalArgumentList(context);
      jj_consume_token(CLTPL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
      jj_consume_token(EQ);
      default_value = DefaultValue();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    {if (true) return new JTENodeArgument(context, dotted, parameter, default_value);}
    throw new Error("Missing return statement in function");
  }

  final public JTENodeArgumentList JavaTemplateFormalArgumentList(CallContext context) throws ParseException {
                                                                             Token token; JTENodeArgumentList result; JTENodeArgument argument;
    result = new JTENodeArgumentList(context);
    argument = JavaTemplateFormalArgument(context);
                                                                                result.append(context, argument);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      argument = JavaTemplateFormalArgument(context);
                                                                                result.append(context, argument);
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public JTENodeArgument JavaTemplateArgument(CallContext context) throws ParseException {
                                                               Token token; String dotted; JTENodeArgumentList parameter = null;
    boolean is_code = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEMPLATE:
    case REQUIRES:
    case IDENTIFIER:
      dotted = DottedIdentifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      break;
    case AT2:
      jj_consume_token(AT2);
      dotted = AnyButAT();
      jj_consume_token(AT2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
                                                         is_code = true;
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPTPL:
      jj_consume_token(OPTPL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      parameter = JavaTemplateArgumentList(context);
      jj_consume_token(CLTPL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    {if (true) return new JTENodeArgument(context, dotted, parameter, is_code);}
    throw new Error("Missing return statement in function");
  }

  final public JTENodeArgumentList JavaTemplateArgumentList(CallContext context) throws ParseException {
                                                                       Token token; JTENodeArgumentList result; JTENodeArgument argument;
    result = new JTENodeArgumentList(context);
    argument = JavaTemplateArgument(context);
                                                                          result.append(context, argument);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      argument = JavaTemplateArgument(context);
                                                                          result.append(context, argument);
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode JavaTemplateExpression(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                                           JTENodeArgumentList list;
    jj_consume_token(OPTPL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NL:
      WSNL();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    list = JavaTemplateArgumentList(context);
    jj_consume_token(CLTPL);
                                                                          current_node =  tch.handleJavaTemplateExpression(context, event, current_node, list);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public Token AnyButCommaNL() throws ParseException {
                          Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      token = jj_consume_token(LT);
      break;
    case GT:
      token = jj_consume_token(GT);
      break;
    case DOT:
      token = jj_consume_token(DOT);
      break;
    case EQ:
      token = jj_consume_token(EQ);
      break;
    case ANY:
      token = jj_consume_token(ANY);
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final public Token Any() throws ParseException {
                Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
    case GT:
    case DOT:
    case EQ:
    case ANY:
      token = AnyButCommaNL();
      break;
    case COMMA:
      token = jj_consume_token(COMMA);
      break;
    case NL:
      token = jj_consume_token(NL);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode PlainText(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                             Token token; StringBuffer value;
    value = new StringBuffer();
    label_6:
    while (true) {
      token = Any();
                                     value.append(token.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                                     value.append(token.image);
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case GT:
      case COMMA:
      case DOT:
      case EQ:
      case NL:
      case ANY:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_6;
      }
    }
    current_node = tch.handlePlainText(context, event, current_node, value.toString());
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode FirstPlainText(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                                  Token token; StringBuffer value;
    value = new StringBuffer();
    token = AnyButCommaNL();
                                     value.append(token.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      token = jj_consume_token(WS);
                                     value.append(token.image);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case GT:
      case COMMA:
      case DOT:
      case EQ:
      case NL:
      case ANY:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_7;
      }
      token = Any();
                                     value.append(token.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                                     value.append(token.image);
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
    }
    current_node = tch.handlePlainText(context, event, current_node, value.toString());
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode White(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                         Token ws;
    ws = jj_consume_token(WS);
              current_node = tch.handlePlainText(context, event, current_node, ws == null ? null : ws.image);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode WhiteNewLine(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                                Token token; StringBuffer value;
    value = new StringBuffer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      token = jj_consume_token(WS);
                   value.append(token.image);
      break;
    case NL:
      token = jj_consume_token(NL);
                   value.append(token.image);
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    current_node = tch.handlePlainText(context, event, current_node, value.toString());
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode AllButFirstWSNL(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                                   Token token; StringBuffer value;
    value = new StringBuffer();
    jj_consume_token(NL);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                     value.append(token.image);
        break;
      case NL:
        token = jj_consume_token(NL);
                     value.append(token.image);
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    current_node = tch.handlePlainText(context, event, current_node, value.toString());
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Code(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                        String code;
    jj_consume_token(AT2);
    code = AnyButAT();
    jj_consume_token(AT2);
                                        current_node = tch.handleCode(context, event, current_node, code);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      current_node = White(context, event, current_node);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Identifier(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                              Token token;
    token = AnyIdentifier();
                               current_node = tch.handleIdentifier(context, event, current_node, token.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      current_node = White(context, event, current_node);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode OnlyIdentifier(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                                  Token token;
    token = jj_consume_token(IDENTIFIER);
                           current_node = tch.handleIdentifier(context, event, current_node, token.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      current_node = White(context, event, current_node);
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Requirement(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                               Token token; String dotted; JTENodeArgumentList list;
    dotted = DottedIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NL:
      WSNL();
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    jj_consume_token(OPTPL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NL:
      WSNL();
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    list = JavaTemplateArgumentList(context);
    jj_consume_token(CLTPL);
                                                   current_node = tch.handleJavaTemplateRequirement(context, event, current_node, dotted, list);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NL:
      current_node = AllButFirstWSNL(context, event, current_node);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode TemplateRequirements(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
    jj_consume_token(REQUIRES);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NL:
      WSNL();
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    current_node = Requirement(context, event, current_node);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case NL:
        WSNL();
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      current_node = Requirement(context, event, current_node);
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode TemplateDeclaration(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                                       Token token; JTENodeArgumentList list;
    jj_consume_token(TEMPLATE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NL:
      WSNL();
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    jj_consume_token(OPTPL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NL:
      WSNL();
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    list = JavaTemplateFormalArgumentList(context);
    jj_consume_token(CLTPL);
                                current_node = tch.handleJavaTemplateDeclaration(context, event, current_node, list);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NL:
      current_node = AllButFirstWSNL(context, event, current_node);
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REQUIRES:
      current_node = TemplateRequirements(context, event, current_node);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode NextText(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      current_node = White(context, event, current_node);
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
    case GT:
    case COMMA:
    case DOT:
    case EQ:
    case NL:
    case ANY:
      current_node = PlainText(context, event, current_node);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
      case REQUIRES:
      case IDENTIFIER:
      case OPTPL:
      case AT2:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
      case REQUIRES:
      case IDENTIFIER:
        current_node = Identifier(context, event, current_node);
        break;
      case AT2:
        current_node = Code(context, event, current_node);
        break;
      case OPTPL:
        current_node = JavaTemplateExpression(context, event, current_node);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          current_node = White(context, event, current_node);
          break;
        default:
          jj_la1[51] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case GT:
      case COMMA:
      case DOT:
      case EQ:
      case NL:
      case ANY:
        current_node = PlainText(context, event, current_node);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
    }
    jj_consume_token(0);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode FirstText(CallContext context, TCEvent event, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NL:
      current_node = WhiteNewLine(context, event, current_node);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEMPLATE:
      current_node = TemplateDeclaration(context, event, current_node);
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case OPTPL:
    case LT:
    case GT:
    case DOT:
    case EQ:
    case AT2:
    case ANY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case GT:
      case DOT:
      case EQ:
      case ANY:
        current_node = FirstPlainText(context, event, current_node);
        break;
      case IDENTIFIER:
      case OPTPL:
      case AT2:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          current_node = OnlyIdentifier(context, event, current_node);
          break;
        case AT2:
          current_node = Code(context, event, current_node);
          break;
        case OPTPL:
          current_node = JavaTemplateExpression(context, event, current_node);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            current_node = White(context, event, current_node);
            break;
          default:
            jj_la1[56] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[57] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
        case GT:
        case COMMA:
        case DOT:
        case EQ:
        case NL:
        case ANY:
          current_node = PlainText(context, event, current_node);
          break;
        default:
          jj_la1[58] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TEMPLATE:
        case REQUIRES:
        case IDENTIFIER:
        case OPTPL:
        case AT2:
          ;
          break;
        default:
          jj_la1[60] = jj_gen;
          break label_11;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TEMPLATE:
        case REQUIRES:
        case IDENTIFIER:
          current_node = Identifier(context, event, current_node);
          break;
        case AT2:
          current_node = Code(context, event, current_node);
          break;
        case OPTPL:
          current_node = JavaTemplateExpression(context, event, current_node);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            current_node = White(context, event, current_node);
            break;
          default:
            jj_la1[61] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[62] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
        case GT:
        case COMMA:
        case DOT:
        case EQ:
        case NL:
        case ANY:
          current_node = PlainText(context, event, current_node);
          break;
        default:
          jj_la1[63] = jj_gen;
          ;
        }
      }
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
    jj_consume_token(0);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  public JavaTemplateTextPPTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[65];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xe,0x2000,0x2000,0x30000,0x30000,0x7ecfe,0x7ecfe,0x77f0e,0x77f0e,0x30000,0x30000,0x30000,0x100,0x4000,0x1000,0x30000,0x30000,0x30000,0x800e,0x30000,0x30000,0x100,0x1000,0x30000,0x30000,0x46c00,0x67c00,0x10000,0x67c00,0x10000,0x67c00,0x10000,0x30000,0x30000,0x30000,0x10000,0x10000,0x10000,0x30000,0x30000,0x20000,0x30000,0x1000,0x30000,0x30000,0x30000,0x20000,0x4,0x10000,0x67c00,0x810e,0x10000,0x810e,0x67c00,0x30000,0x2,0x10000,0x8108,0x67c00,0x4ed08,0x810e,0x10000,0x810e,0x67c00,0x4ed08,};
   }

  public JavaTemplateTextPP(java.io.InputStream stream) {
     this(stream, null);
  }
  public JavaTemplateTextPP(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JavaTemplateTextPPTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public JavaTemplateTextPP(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new JavaTemplateTextPPTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public JavaTemplateTextPP(JavaTemplateTextPPTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public void ReInit(JavaTemplateTextPPTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[19];
    for (int i = 0; i < 19; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 65; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 19; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
