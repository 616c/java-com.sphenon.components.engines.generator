/* Generated By:JavaCC: Do not edit this line. TemplateCode.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.engines.generator.tchandler.classes;

import com.sphenon.basics.context.*;
import com.sphenon.engines.generator.*;
import com.sphenon.engines.generator.tom.*;
import com.sphenon.engines.generator.returncodes.*;

import java.io.Reader;
import java.io.Writer;
import java.io.IOException;

import java.util.Vector;

public class TemplateCode implements TemplateCodeConstants {

  protected Writer          out;
  protected TCHTemplateCode tch;

  public TemplateCode (CallContext context, Reader in, TCHTemplateCode tch) {
      this(in);
      this.out = out;
      this.tch = tch;
  }

  public String getPosition(CallContext context) {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public void Block(CallContext context, StringBuffer value) throws ParseException {
                                                        Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      token = jj_consume_token(OPPAR);
                          value.append(token.image);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case COMMA:
        case COLON:
        case EQUAL:
        case DOT:
        case SLASH:
        case ANY:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        JavaCodeBalanced(context, value);
      }
      token = jj_consume_token(CLPAR);
                          value.append(token.image);
      break;
    case OPBRC:
      token = jj_consume_token(OPBRC);
                          value.append(token.image);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case COMMA:
        case COLON:
        case EQUAL:
        case DOT:
        case SLASH:
        case ANY:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        JavaCodeBalanced(context, value);
      }
      token = jj_consume_token(CLBRC);
                          value.append(token.image);
      break;
    case OPBRK:
      token = jj_consume_token(OPBRK);
                          value.append(token.image);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case COMMA:
        case COLON:
        case EQUAL:
        case DOT:
        case SLASH:
        case ANY:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_3;
        }
        JavaCodeBalanced(context, value);
      }
      token = jj_consume_token(CLBRK);
                          value.append(token.image);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void TokensButComma(CallContext context, StringBuffer value) throws ParseException {
                                                                 Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
      token = jj_consume_token(CHARACTER_LITERAL);
                                  value.append(token.image);
      break;
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
                                  value.append(token.image);
      break;
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
                                  value.append(token.image);
      break;
    case COLON:
      token = jj_consume_token(COLON);
                                  value.append(token.image);
      break;
    case EQUAL:
      token = jj_consume_token(EQUAL);
                                  value.append(token.image);
      break;
    case DOT:
      token = jj_consume_token(DOT);
                                  value.append(token.image);
      break;
    case SLASH:
      token = jj_consume_token(SLASH);
                                  value.append(token.image);
      break;
    case LT:
      token = jj_consume_token(LT);
                                  value.append(token.image);
      break;
    case GT:
      token = jj_consume_token(GT);
                                  value.append(token.image);
      break;
    case ANY:
      token = jj_consume_token(ANY);
                                  value.append(token.image);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Tokens(CallContext context, StringBuffer value) throws ParseException {
                                                         Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LT:
    case GT:
    case COLON:
    case EQUAL:
    case DOT:
    case SLASH:
    case ANY:
      TokensButComma(context, value);
      break;
    case COMMA:
      token = jj_consume_token(COMMA);
                                  value.append(token.image);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void JavaCodeBalanced(CallContext context, StringBuffer value) throws ParseException {
                                                                   Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
    case OPBRC:
    case OPBRK:
      Block(context, value);
      break;
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LT:
    case GT:
    case COMMA:
    case COLON:
    case EQUAL:
    case DOT:
    case SLASH:
    case ANY:
      Tokens(context, value);
      break;
    case WS:
      token = jj_consume_token(WS);
                   value.append(token.image);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void JavaCodeBalancedButComma(CallContext context, StringBuffer value) throws ParseException {
                                                                           Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
    case OPBRC:
    case OPBRK:
      Block(context, value);
      break;
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LT:
    case GT:
    case COLON:
    case EQUAL:
    case DOT:
    case SLASH:
    case ANY:
      TokensButComma(context, value);
      break;
    case WS:
      token = jj_consume_token(WS);
                   value.append(token.image);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String Array() throws ParseException {
                   String result; String array=null;
    jj_consume_token(OPBRK);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(CLBRK);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      jj_consume_token(WS);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPBRK:
      array = Array();
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
                                                                    result = "[]" + (array == null ? "" : array);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String TemplateArgs() throws ParseException {
                          String type; String templateargs = null;
    type = Type();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
        jj_consume_token(WS);
      }
      templateargs = TemplateArgs();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    {if (true) return type + (templateargs == null ? "" : ("," + templateargs));}
    throw new Error("Missing return statement in function");
  }

  final public String Type() throws ParseException {
                  String type; String templateargs = null; String array = null; String result;
    type = DottedIdentifier();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_7;
      }
      jj_consume_token(WS);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      jj_consume_token(LT);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_8;
        }
        jj_consume_token(WS);
      }
      templateargs = TemplateArgs();
      jj_consume_token(GT);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_9;
        }
        jj_consume_token(WS);
      }
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPBRK:
      array = Array();
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
        result = type + (templateargs == null ? "" : ("<" + templateargs + ">")) + (array == null ? "" : array);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public StringBuffer DefaultValue(CallContext context) throws ParseException {
                                                   StringBuffer default_value;
    default_value = new StringBuffer();
    label_10:
    while (true) {
      JavaCodeBalancedButComma(context, default_value);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case LT:
      case GT:
      case COLON:
      case EQUAL:
      case DOT:
      case SLASH:
      case ANY:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_10;
      }
    }
    {if (true) return default_value;}
    throw new Error("Missing return statement in function");
  }

  final public TCodeArgument Argument(CallContext context) throws ParseException {
                                                Token token; String type; StringBuffer default_value=null;
    TCodeArgument result = null;
    type = Type();
    token = jj_consume_token(IDENTIFIER);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_11;
      }
      jj_consume_token(WS);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      default_value = DefaultValue(context);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
                                                                                                      result = new TCodeArgument(context, token.image, type, default_value == null ? null : default_value.toString());
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Vector ArgumentList(CallContext context) throws ParseException {
                                             Token token; TCodeArgument argument; Vector arglist = null;
    argument = Argument(context);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_12;
        }
        jj_consume_token(WS);
      }
      arglist = ArgumentList(context);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
                                                                                             (arglist == null ? (arglist = new Vector()) : arglist).add(0, argument);
    {if (true) return arglist;}
    throw new Error("Missing return statement in function");
  }

  final public String DotIdentifier() throws ParseException {
                           Token token; String result; String postfix;
    postfix = "";
    jj_consume_token(DOT);
    token = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      postfix = DotIdentifier();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
                                                              result = "." + token.image + postfix;
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String DottedIdentifier() throws ParseException {
                              Token token; String result; String postfix;
    postfix = "";
    token = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      postfix = DotIdentifier();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
                                                        result = token.image + postfix;
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Signature(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                              Vector signature;
    jj_consume_token(SIGNATURE);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_13;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(OPPAR);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_14;
      }
      jj_consume_token(WS);
    }
    signature = ArgumentList(context);
    jj_consume_token(CLPAR);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_15;
      }
      jj_consume_token(WS);
    }
    {if (true) return tch.handleSignature(context, current_node, signature);}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Name(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                         StringBuffer value;
    value = new StringBuffer();
    jj_consume_token(NAME);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_16;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(OPPAR);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case LT:
      case GT:
      case COMMA:
      case COLON:
      case EQUAL:
      case DOT:
      case SLASH:
      case ANY:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_17;
      }
      JavaCodeBalanced(context, value);
    }
    jj_consume_token(CLPAR);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_18;
      }
      jj_consume_token(WS);
    }
    {if (true) return tch.handleName(context, current_node, value.toString());}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode LastDataModification(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                         StringBuffer value;
    value = new StringBuffer();
    jj_consume_token(LASTMODIFICATION);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[31] = jj_gen;
        break label_19;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(OPPAR);
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case LT:
      case GT:
      case COMMA:
      case COLON:
      case EQUAL:
      case DOT:
      case SLASH:
      case ANY:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_20;
      }
      JavaCodeBalanced(context, value);
    }
    jj_consume_token(CLPAR);
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_21;
      }
      jj_consume_token(WS);
    }
    {if (true) return tch.handleLastDataModification(context, current_node, value.toString());}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode PartitionBegin(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                   StringBuffer value; StringBuffer value2; StringBuffer value3;
    value = new StringBuffer();
    value2 = new StringBuffer();
    value3 = new StringBuffer();
    jj_consume_token(PARTITION);
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_22;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(OPPAR);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case LT:
      case GT:
      case COLON:
      case EQUAL:
      case DOT:
      case SLASH:
      case ANY:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_23;
      }
      JavaCodeBalancedButComma(context, value);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case COLON:
        case EQUAL:
        case DOT:
        case SLASH:
        case ANY:
          ;
          break;
        default:
          jj_la1[36] = jj_gen;
          break label_24;
        }
        JavaCodeBalancedButComma(context, value2);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        label_25:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case IDENTIFIER:
          case OPPAR:
          case OPBRC:
          case OPBRK:
          case LT:
          case GT:
          case COLON:
          case EQUAL:
          case DOT:
          case SLASH:
          case ANY:
            ;
            break;
          default:
            jj_la1[37] = jj_gen;
            break label_25;
          }
          JavaCodeBalancedButComma(context, value3);
        }
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    jj_consume_token(CLPAR);
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_26;
      }
      jj_consume_token(WS);
    }
    {if (true) return tch.handlePartitionBegin(context, current_node, value.toString(), value2.length() == 0 ? "false" : value2.toString(), value3.length() == 0 ? "false" : value3.toString());}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode LocatorTarget(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                  Token token; Vector arguments=null;
    jj_consume_token(LOCTGT);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_27;
      }
      jj_consume_token(WS);
    }
    token = jj_consume_token(IDENTIFIER);
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_28;
      }
      jj_consume_token(WS);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[43] = jj_gen;
          break label_29;
        }
        jj_consume_token(WS);
      }
      jj_consume_token(OPPAR);
      label_30:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_30;
        }
        jj_consume_token(WS);
      }
      arguments = ArgumentList(context);
      jj_consume_token(CLPAR);
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_31;
        }
        jj_consume_token(WS);
      }
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    {if (true) return tch.handleLocatorTarget(context, current_node, token.image, arguments);}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode TemplateBegin(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                  Vector signature = null; Token token;
    String template_name;
    jj_consume_token(TEMPLATE);
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_32;
      }
      jj_consume_token(WS);
    }
    token = jj_consume_token(IDENTIFIER);
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_33;
      }
      jj_consume_token(WS);
    }
                                      template_name = token.image;
    jj_consume_token(OPPAR);
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_34;
      }
      jj_consume_token(WS);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      signature = ArgumentList(context);
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    jj_consume_token(CLPAR);
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_35;
      }
      jj_consume_token(WS);
    }
    {if (true) return tch.handleTemplateBegin(context, current_node, template_name, signature);}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Insert(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                           StringBuffer value; StringBuffer template_name_code; Token token;
    value = new StringBuffer();
    template_name_code = new StringBuffer();
    String template_name = null;
    String generator_name = null;
    jj_consume_token(INSERT);
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_36;
      }
      jj_consume_token(WS);
    }
    if (jj_2_1(2147483647)) {
      token = jj_consume_token(IDENTIFIER);
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[53] = jj_gen;
          break label_37;
        }
        jj_consume_token(WS);
      }
      jj_consume_token(EQUAL);
      label_38:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[54] = jj_gen;
          break label_38;
        }
        jj_consume_token(WS);
      }
                                                             generator_name = token.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        template_name = DottedIdentifier();
        label_39:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[55] = jj_gen;
            break label_39;
          }
          jj_consume_token(WS);
        }
        break;
      case OPPAR:
        jj_consume_token(OPPAR);
        label_40:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case IDENTIFIER:
          case OPPAR:
          case OPBRC:
          case OPBRK:
          case LT:
          case GT:
          case COMMA:
          case COLON:
          case EQUAL:
          case DOT:
          case SLASH:
          case ANY:
            ;
            break;
          default:
            jj_la1[56] = jj_gen;
            break label_40;
          }
          JavaCodeBalanced(context, template_name_code);
        }
        jj_consume_token(CLPAR);
        label_41:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[57] = jj_gen;
            break label_41;
          }
          jj_consume_token(WS);
        }
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case OPPAR:
      case OPBRK:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          template_name = DottedIdentifier();
          label_42:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              ;
              break;
            default:
              jj_la1[59] = jj_gen;
              break label_42;
            }
            jj_consume_token(WS);
          }
          break;
        case OPPAR:
          jj_consume_token(OPPAR);
          label_43:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case IDENTIFIER:
            case OPPAR:
            case OPBRC:
            case OPBRK:
            case LT:
            case GT:
            case COMMA:
            case COLON:
            case EQUAL:
            case DOT:
            case SLASH:
            case ANY:
              ;
              break;
            default:
              jj_la1[60] = jj_gen;
              break label_43;
            }
            JavaCodeBalanced(context, template_name_code);
          }
          jj_consume_token(CLPAR);
          label_44:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              ;
              break;
            default:
              jj_la1[61] = jj_gen;
              break label_44;
            }
            jj_consume_token(WS);
          }
          break;
        case OPBRK:
          jj_consume_token(OPBRK);
          label_45:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              ;
              break;
            default:
              jj_la1[62] = jj_gen;
              break label_45;
            }
            jj_consume_token(WS);
          }
          token = jj_consume_token(IDENTIFIER);
          label_46:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              ;
              break;
            default:
              jj_la1[63] = jj_gen;
              break label_46;
            }
            jj_consume_token(WS);
          }
          jj_consume_token(CLBRK);
          label_47:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WS:
              ;
              break;
            default:
              jj_la1[64] = jj_gen;
              break label_47;
            }
            jj_consume_token(WS);
          }
                                                                                         generator_name = token.image;
          break;
        default:
          jj_la1[65] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(OPPAR);
        label_48:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case IDENTIFIER:
          case OPPAR:
          case OPBRC:
          case OPBRK:
          case LT:
          case GT:
          case COMMA:
          case COLON:
          case EQUAL:
          case DOT:
          case SLASH:
          case ANY:
            ;
            break;
          default:
            jj_la1[66] = jj_gen;
            break label_48;
          }
          JavaCodeBalanced(context, value);
        }
        jj_consume_token(CLPAR);
        label_49:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[67] = jj_gen;
            break label_49;
          }
          jj_consume_token(WS);
        }
        break;
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return tch.handleInsert(context, current_node, generator_name, template_name, template_name_code.toString(), value.toString());}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Polymorphic(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                Token polytype=null;
    jj_consume_token(POLYMORPHIC);
    label_50:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_50;
      }
      jj_consume_token(WS);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      jj_consume_token(OPPAR);
      label_51:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[70] = jj_gen;
          break label_51;
        }
        jj_consume_token(WS);
      }
      polytype = jj_consume_token(IDENTIFIER);
      label_52:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[71] = jj_gen;
          break label_52;
        }
        jj_consume_token(WS);
      }
      jj_consume_token(CLPAR);
      label_53:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[72] = jj_gen;
          break label_53;
        }
        jj_consume_token(WS);
      }
      break;
    default:
      jj_la1[73] = jj_gen;
      ;
    }
    {if (true) return tch.handlePolymorphic(context, current_node, polytype != null ? polytype.image : "Class");}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Override(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
    jj_consume_token(OVERRIDE);
    label_54:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_54;
      }
      jj_consume_token(WS);
    }
    {if (true) return tch.handleOverride(context, current_node);}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Base(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
    String base_name;
    jj_consume_token(BASE);
    label_55:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[75] = jj_gen;
        break label_55;
      }
      jj_consume_token(WS);
    }
    base_name = DottedIdentifier();
    label_56:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[76] = jj_gen;
        break label_56;
      }
      jj_consume_token(WS);
    }
    {if (true) return tch.handleBase(context, current_node, base_name);}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Interfaces(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
    StringBuilder interfaces = null;
    String j_interface;
    jj_consume_token(IMPLEMENTS);
    label_57:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[77] = jj_gen;
        break label_57;
      }
      jj_consume_token(WS);
    }
    label_58:
    while (true) {
      j_interface = DottedIdentifier();
      label_59:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[78] = jj_gen;
          break label_59;
        }
        jj_consume_token(WS);
      }
                                                        if (interfaces == null) {
                                                          interfaces= new StringBuilder();
                                                        } else {
                                                          interfaces.append(", ");
                                                        }
                                                        interfaces.append(j_interface);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[79] = jj_gen;
        break label_58;
      }
    }
    {if (true) return tch.handleInterfaces(context, current_node, interfaces.toString());}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Requires(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                             StringBuffer value;
    value = new StringBuffer();
    String template_name;
    jj_consume_token(REQUIRES);
    label_60:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[80] = jj_gen;
        break label_60;
      }
      jj_consume_token(WS);
    }
    template_name = DottedIdentifier();
    label_61:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[81] = jj_gen;
        break label_61;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(OPPAR);
    label_62:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case LT:
      case GT:
      case COMMA:
      case COLON:
      case EQUAL:
      case DOT:
      case SLASH:
      case ANY:
        ;
        break;
      default:
        jj_la1[82] = jj_gen;
        break label_62;
      }
      JavaCodeBalanced(context, value);
    }
    jj_consume_token(CLPAR);
    label_63:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[83] = jj_gen;
        break label_63;
      }
      jj_consume_token(WS);
    }
    {if (true) return tch.handleRequirement(context, current_node, template_name, value.toString());}
    throw new Error("Missing return statement in function");
  }

  final public Vector Recoding(CallContext context, Vector recoding) throws ParseException {
                                                          Token reco = null; StringBuffer value;
    value = new StringBuffer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      reco = jj_consume_token(IDENTIFIER);
      label_64:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[84] = jj_gen;
          break label_64;
        }
        jj_consume_token(WS);
      }
      break;
    default:
      jj_la1[85] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      jj_consume_token(OPPAR);
      label_65:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case LT:
        case GT:
        case COMMA:
        case COLON:
        case EQUAL:
        case DOT:
        case SLASH:
        case ANY:
          ;
          break;
        default:
          jj_la1[86] = jj_gen;
          break label_65;
        }
        JavaCodeBalanced(context, value);
      }
      jj_consume_token(CLPAR);
      label_66:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[87] = jj_gen;
          break label_66;
        }
        jj_consume_token(WS);
      }
      break;
    default:
      jj_la1[88] = jj_gen;
      ;
    }
      if (recoding == null) { recoding = new Vector(); }
      String[] recoentry = new String[2];
      recoentry[0] = (reco == null ? null : reco.image);
      recoentry[1] = value.toString();
      recoding.add(recoentry);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
    case SLASH:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH:
        jj_consume_token(SLASH);
        label_67:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[89] = jj_gen;
            break label_67;
          }
          jj_consume_token(WS);
        }
        recoding = Recoding(context, recoding);
        break;
      case COMMA:
        jj_consume_token(COMMA);
        label_68:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[90] = jj_gen;
            break label_68;
          }
          jj_consume_token(WS);
        }
                              recoding.add(null);
        recoding = Recoding(context, recoding);
        break;
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[92] = jj_gen;
      ;
    }
    {if (true) return recoding;}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode RecodingBegin(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                  Token applies_to = null;
    Vector recoding=null;
    jj_consume_token(RECODING);
    label_69:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[93] = jj_gen;
        break label_69;
      }
      jj_consume_token(WS);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPBRK:
      jj_consume_token(OPBRK);
      applies_to = jj_consume_token(IDENTIFIER);
      jj_consume_token(CLBRK);
      label_70:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[94] = jj_gen;
          break label_70;
        }
        jj_consume_token(WS);
      }
      break;
    default:
      jj_la1[95] = jj_gen;
      ;
    }
    recoding = Recoding(context, null);
    {if (true) return tch.handleRecodingBegin(context, current_node, recoding, applies_to == null ? null : applies_to.image);}
    throw new Error("Missing return statement in function");
  }

  final public TOMNode End(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case END:
      jj_consume_token(END);
      label_71:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[96] = jj_gen;
          break label_71;
        }
        jj_consume_token(WS);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARTITION:
        jj_consume_token(PARTITION);
        label_72:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[97] = jj_gen;
            break label_72;
          }
          jj_consume_token(WS);
        }
                                            {if (true) return tch.handlePartitionEnd(context, current_node);}
        break;
      case TEMPLATE:
        jj_consume_token(TEMPLATE);
        label_73:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[98] = jj_gen;
            break label_73;
          }
          jj_consume_token(WS);
        }
                                            {if (true) return tch.handleTemplateEnd(context, current_node);}
        break;
      case RECODING:
        jj_consume_token(RECODING);
        label_74:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[99] = jj_gen;
            break label_74;
          }
          jj_consume_token(WS);
        }
                                            {if (true) return tch.handleRecodingEnd(context, current_node);}
        break;
      default:
        jj_la1[100] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case ENDTEMPLATE:
    case ENDPARTITION:
    case ENDRECODING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ENDPARTITION:
        jj_consume_token(ENDPARTITION);
        label_75:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[101] = jj_gen;
            break label_75;
          }
          jj_consume_token(WS);
        }
                                            {if (true) return tch.handlePartitionEnd(context, current_node);}
        break;
      case ENDTEMPLATE:
        jj_consume_token(ENDTEMPLATE);
        label_76:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[102] = jj_gen;
            break label_76;
          }
          jj_consume_token(WS);
        }
                                            {if (true) return tch.handleTemplateEnd(context, current_node);}
        break;
      case ENDRECODING:
        jj_consume_token(ENDRECODING);
        label_77:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[103] = jj_gen;
            break label_77;
          }
          jj_consume_token(WS);
        }
                                            {if (true) return tch.handleRecodingEnd(context, current_node);}
        break;
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[105] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public TOMNode TemplateCode(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                  Token token;
    label_78:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[106] = jj_gen;
        break label_78;
      }
      jj_consume_token(WS);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIGNATURE:
      current_node = Signature(context, current_node);
      break;
    case NAME:
      current_node = Name(context, current_node);
      break;
    case LASTMODIFICATION:
      current_node = LastDataModification(context, current_node);
      break;
    case LOCTGT:
      current_node = LocatorTarget(context, current_node);
      break;
    case TEMPLATE:
      current_node = TemplateBegin(context, current_node);
      break;
    case INSERT:
      current_node = Insert(context, current_node);
      break;
    case BASE:
      current_node = Base(context, current_node);
      break;
    case IMPLEMENTS:
      current_node = Interfaces(context, current_node);
      break;
    case POLYMORPHIC:
      current_node = Polymorphic(context, current_node);
      break;
    case OVERRIDE:
      current_node = Override(context, current_node);
      break;
    case REQUIRES:
      current_node = Requires(context, current_node);
      break;
    case PARTITION:
      current_node = PartitionBegin(context, current_node);
      break;
    case RECODING:
      current_node = RecodingBegin(context, current_node);
      break;
    case ENDTEMPLATE:
    case ENDPARTITION:
    case ENDRECODING:
    case END:
      current_node = End(context, current_node);
      break;
    default:
      jj_la1[107] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(0);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(1)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  public TemplateCodeTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[108];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xf5780002,0xf5780002,0xf5780002,0x5400000,0xb0380000,0xf0380000,0xf5780002,0xb5780002,0x2,0x2,0x4000000,0x2,0x40000000,0x2,0x2,0x2,0x10000000,0x4000000,0xb5780002,0x2,0x0,0x2,0x40000000,0x0,0x0,0x2,0x2,0x2,0x2,0xf5780002,0x2,0x2,0xf5780002,0x2,0x2,0xb5780002,0xb5780002,0xb5780002,0x40000000,0x40000000,0x2,0x2,0x2,0x2,0x2,0x2,0x0,0x2,0x2,0x2,0x200000,0x2,0x2,0x2,0x2,0x2,0xf5780002,0x2,0x600000,0x2,0xf5780002,0x2,0x2,0x2,0x2,0x4600000,0xf5780002,0x2,0x4600000,0x2,0x2,0x2,0x2,0x400000,0x2,0x2,0x2,0x2,0x2,0x200000,0x2,0x2,0xf5780002,0x2,0x2,0x200000,0xf5780002,0x2,0x400000,0x2,0x2,0x40000000,0x40000000,0x2,0x2,0x4000000,0x2,0x2,0x2,0x2,0x14010,0x2,0x2,0x2,0x28020,0x68020,0x2,0x7fffc,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0xf,0xf,0xf,0x0,0xf,0xf,0xf,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x0,0x1,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0xf,0x0,0x0,0xf,0x0,0x0,0xf,0xf,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x0,0x0,0x0,0xf,0x0,0x0,0x0,0x0,0x0,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x0,0x0,0x0,0xf,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public TemplateCode(java.io.InputStream stream) {
     this(stream, null);
  }
  public TemplateCode(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TemplateCodeTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 108; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 108; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TemplateCode(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TemplateCodeTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 108; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 108; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TemplateCode(TemplateCodeTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 108; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(TemplateCodeTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 108; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[36];
    for (int i = 0; i < 36; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 108; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 36; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
