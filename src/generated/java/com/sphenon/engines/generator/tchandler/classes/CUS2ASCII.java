/* Generated By:JavaCC: Do not edit this line. CUS2ASCII.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.engines.generator.tchandler.classes;

import com.sphenon.basics.context.*;

import java.io.Reader;
import java.io.Writer;
import java.io.IOException;

public class CUS2ASCII implements CUS2ASCIIConstants {

  protected Writer out;
  protected boolean java_template_characters;
  protected boolean model_template_characters;

  public CUS2ASCII (CallContext context, Reader in, Writer out, boolean java_template_characters, boolean model_template_characters) {
      this(in);
      this.out = out;
      this.java_template_characters = java_template_characters;
      this.model_template_characters = model_template_characters;
  }

    public String getPosition(CallContext context) {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public void Token() throws ParseException, IOException {
                                    Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCAPE:
      token = jj_consume_token(ESCAPE);
                             out.append(token.image.charAt(1));
      break;
    case GCBEGIN:
      jj_consume_token(GCBEGIN);
                             out.append("<%");
      break;
    case GCEND:
      jj_consume_token(GCEND);
                             out.append("%>");
      break;
    case CMTBEGIN:
      jj_consume_token(CMTBEGIN);
                             out.append("<%--");
      break;
    case CMTEND:
      jj_consume_token(CMTEND);
                             out.append("--%>");
      break;
    case EXPRBEGIN:
      jj_consume_token(EXPRBEGIN);
                             out.append("<%=");
      break;
    case EXPREND:
      jj_consume_token(EXPREND);
                             out.append("%>");
      break;
    case CLSLVL:
      jj_consume_token(CLSLVL);
                             out.append("<%!");
      break;
    case ECLSLVL:
      jj_consume_token(ECLSLVL);
                             out.append("%>");
      break;
    case FLLVL:
      jj_consume_token(FLLVL);
                             out.append("<%@");
      break;
    case EFLLVL:
      jj_consume_token(EFLLVL);
                             out.append("%>");
      break;
    case RECODING:
      jj_consume_token(RECODING);
                             out.append("%%");
      break;
    case ERECODING:
      jj_consume_token(ERECODING);
                             out.append("/%%");
      break;
    case JOIN:
      jj_consume_token(JOIN);
                             out.append("--(");
      break;
    case EJOIN:
      jj_consume_token(EJOIN);
                             out.append(")--");
      break;
    case CONFIG:
      jj_consume_token(CONFIG);
                             out.append("\u00b0\u00b0");
      break;
    case DYNAMIC:
      jj_consume_token(DYNAMIC);
                             out.append("(*)");
      break;
    case PLACEHOLDER:
      jj_consume_token(PLACEHOLDER);
                             out.append("placeholder");
      break;
    case TCBEGIN:
      jj_consume_token(TCBEGIN);
                             out.append("<%?");
      break;
    case TCEND:
      jj_consume_token(TCEND);
                             out.append("?%>");
      break;
    case JTTBEGIN:
      jj_consume_token(JTTBEGIN);
                             out.append(this.java_template_characters ? "<-" : "\u2264");
      break;
    case JTTEND:
      jj_consume_token(JTTEND);
                             out.append(this.java_template_characters ? "->" : "\u2265");
      break;
    case MTTBEGIN:
      jj_consume_token(MTTBEGIN);
                             out.append(this.model_template_characters ? "<=" : "\u2266");
      break;
    case MTTEND:
      jj_consume_token(MTTEND);
                             out.append(this.model_template_characters ? "=>" : "\u2267");
      break;
    case TAGBEGIN:
      jj_consume_token(TAGBEGIN);
                             out.append("<@");
      break;
    case TAGEND:
      jj_consume_token(TAGEND);
                             out.append("@>");
      break;
    case REGEXP:
      jj_consume_token(REGEXP);
                             out.append("~~~");
      break;
    case TIME:
      jj_consume_token(TIME);
                             out.append("#{time}");
      break;
    case FORMAT:
      jj_consume_token(FORMAT);
                             out.append("#{format}");
      break;
    case SIZE:
      jj_consume_token(SIZE);
                             out.append("#{size}");
      break;
    case AVERAGE:
      jj_consume_token(AVERAGE);
                             out.append("#{average}");
      break;
    case PRODUCT:
      jj_consume_token(PRODUCT);
                             out.append("#{product}");
      break;
    case SUM:
      jj_consume_token(SUM);
                             out.append("#{sum}");
      break;
    case MINIMUM:
      jj_consume_token(MINIMUM);
                             out.append("#{minimum}");
      break;
    case MAXIMUM:
      jj_consume_token(MAXIMUM);
                             out.append("#{maximum}");
      break;
    case REVERSE:
      jj_consume_token(REVERSE);
                             out.append("#{reverse}");
      break;
    case FOR:
      jj_consume_token(FOR);
                             out.append("#{for}");
      break;
    case EFOR:
      jj_consume_token(EFOR);
                             out.append("/#{for}");
      break;
    case SELECT:
      jj_consume_token(SELECT);
                             out.append("#{select}");
      break;
    case ESELECT:
      jj_consume_token(ESELECT);
                             out.append("/#{select}");
      break;
    case INSERT:
      jj_consume_token(INSERT);
                             out.append("#{insert}");
      break;
    case UNION:
      jj_consume_token(UNION);
                             out.append("#{union}");
      break;
    case ELEMENT:
      jj_consume_token(ELEMENT);
                             out.append("#{element}");
      break;
    case EELEMENT:
      jj_consume_token(EELEMENT);
                             out.append("/#{element}");
      break;
    case NOTELEMENT:
      jj_consume_token(NOTELEMENT);
                             out.append("#{notelement}");
      break;
    case ENOTELEMENT:
      jj_consume_token(ENOTELEMENT);
                             out.append("/#{notelement}");
      break;
    case TPL:
      jj_consume_token(TPL);
                             out.append("#{template}");
      break;
    case ETPL:
      jj_consume_token(ETPL);
                             out.append("/#{template}");
      break;
    case PART:
      jj_consume_token(PART);
                             out.append("#{partition}");
      break;
    case EPART:
      jj_consume_token(EPART);
                             out.append("/#{partition}");
      break;
    case EXISTS:
      jj_consume_token(EXISTS);
                             out.append("#{exists}");
      break;
    case EEXISTS:
      jj_consume_token(EEXISTS);
                             out.append("/#{exists}");
      break;
    case NOTEXISTS:
      jj_consume_token(NOTEXISTS);
                             out.append("#{notexists}");
      break;
    case ENOTEXISTS:
      jj_consume_token(ENOTEXISTS);
                             out.append("/#{notexists}");
      break;
    case ISVALID:
      jj_consume_token(ISVALID);
                             out.append("#{isvalid}");
      break;
    case EISVALID:
      jj_consume_token(EISVALID);
                             out.append("/#{isvalid}");
      break;
    case ISINVALID:
      jj_consume_token(ISINVALID);
                             out.append("#{isinvalid}");
      break;
    case EISINVALID:
      jj_consume_token(EISINVALID);
                             out.append("/#{isinvalid}");
      break;
    case CURRENT:
      jj_consume_token(CURRENT);
                             out.append("#{current}()");
      break;
    case INDEXOP:
      jj_consume_token(INDEXOP);
                             out.append("#{index}(");
      break;
    case INDEXDECL:
      jj_consume_token(INDEXDECL);
                             out.append("#{declareindex}");
      break;
    case INDEX:
      jj_consume_token(INDEX);
                             out.append("#{index}()");
      break;
    case MSG:
      jj_consume_token(MSG);
                             out.append("#{message}");
      break;
    case DOCLET:
      jj_consume_token(DOCLET);
                             out.append("#{doclet}");
      break;
    case WORK:
      jj_consume_token(WORK);
                             out.append("#{work}");
      break;
    case INDENT:
      jj_consume_token(INDENT);
                             out.append("#{indent}");
      break;
    case EINDENT:
      jj_consume_token(EINDENT);
                             out.append("/#{indent}");
      break;
    case ADD:
      jj_consume_token(ADD);
                             out.append("#{add}");
      break;
    case REMOVE:
      jj_consume_token(REMOVE);
                             out.append("#{remove}");
      break;
    case CREATE:
      jj_consume_token(CREATE);
                             out.append("#{create}");
      break;
    case FIRSTOP:
      jj_consume_token(FIRSTOP);
                             out.append("#{first}(");
      break;
    case FIRSTDECL:
      jj_consume_token(FIRSTDECL);
                             out.append("#{declarepass}");
      break;
    case FIRST:
      jj_consume_token(FIRST);
                             out.append("#{first}()");
      break;
    case NOTFIRSTOP:
      jj_consume_token(NOTFIRSTOP);
                             out.append("#{notfirst}(");
      break;
    case NOTFIRST:
      jj_consume_token(NOTFIRST);
                             out.append("#{notfirst}()");
      break;
    case LAST:
      jj_consume_token(LAST);
                             out.append("#{last}()");
      break;
    case NOTLAST:
      jj_consume_token(NOTLAST);
                             out.append("#{notlast}()");
      break;
    case EFIRST:
      jj_consume_token(EFIRST);
                             out.append("/#{first}");
      break;
    case ENOTFIRST:
      jj_consume_token(ENOTFIRST);
                             out.append("/#{notfirst}");
      break;
    case ELAST:
      jj_consume_token(ELAST);
                             out.append("/#{last}");
      break;
    case ENOTLAST:
      jj_consume_token(ENOTLAST);
                             out.append("/#{notlast}");
      break;
    case EMPTY:
      jj_consume_token(EMPTY);
                             out.append("#{empty}");
      break;
    case NOTEMPTY:
      jj_consume_token(NOTEMPTY);
                             out.append("#{notempty}");
      break;
    case NOT:
      jj_consume_token(NOT);
                             out.append("#{not}");
      break;
    case ELSE:
      jj_consume_token(ELSE);
                             out.append("}#{else}(){");
      break;
    case OR:
      jj_consume_token(OR);
                             out.append("||");
      break;
    case AND:
      jj_consume_token(AND);
                             out.append("&&");
      break;
    case ISA:
      jj_consume_token(ISA);
                             out.append("#{isa}");
      break;
    case NOTISA:
      jj_consume_token(NOTISA);
                             out.append("#{notisa}");
      break;
    case XPATH:
      jj_consume_token(XPATH);
                             out.append("XPath");
      break;
    case PROPERTY:
      jj_consume_token(PROPERTY);
                             out.append("Property");
      break;
    case XMODEL:
      jj_consume_token(XMODEL);
                             out.append("XModel");
      break;
    case FILE:
      jj_consume_token(FILE);
                             out.append("File");
      break;
    case SQL:
      jj_consume_token(SQL);
                             out.append("SQL");
      break;
    case OQL:
      jj_consume_token(OQL);
                             out.append("OQL");
      break;
    case NULL:
      jj_consume_token(NULL);
                             out.append("null");
      break;
    case TRUE:
      jj_consume_token(TRUE);
                             out.append("true");
      break;
    case FALSE:
      jj_consume_token(FALSE);
                             out.append("false");
      break;
    case EQUALS:
      jj_consume_token(EQUALS);
                             out.append(".equals");
      break;
    case LOCATOR:
      jj_consume_token(LOCATOR);
                             out.append(" ::");
      break;
    case PERPER:
      jj_consume_token(PERPER);
                             out.append("\\%\\%");
      break;
    case PERCLO:
      jj_consume_token(PERCLO);
                             out.append("\\%\\>");
      break;
    case OPEPER:
      jj_consume_token(OPEPER);
                             out.append("\\<\\%");
      break;
    case DSHCLO:
      jj_consume_token(DSHCLO);
                             out.append(this.java_template_characters ? "\\-\\>" : "->");
      break;
    case OPEDSH:
      jj_consume_token(OPEDSH);
                             out.append(this.java_template_characters ? "\\<\\-" : "<-");
      break;
    case EQUCLO:
      jj_consume_token(EQUCLO);
                             out.append(this.model_template_characters ? "\\=\\>" : "=>");
      break;
    case OPEEQU:
      jj_consume_token(OPEEQU);
                             out.append(this.model_template_characters ? "\\<\\=" : "<=");
      break;
    case BACKSL:
      jj_consume_token(BACKSL);
                             out.append("\\\\");
      break;
    case NEWLINE:
      jj_consume_token(NEWLINE);
                             out.append("\\n");
      break;
    case IGNORE:
      jj_consume_token(IGNORE);

      break;
    case DELIM:
      token = jj_consume_token(DELIM);
                             out.append(token.image);
      break;
    case ANY:
      token = jj_consume_token(ANY);
                             out.append(token.image);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Expression() throws ParseException, IOException {
                                         Token token=null;
    jj_consume_token(EXPRB);
                             out.append("{*");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELT:
      jj_consume_token(ELT);
                             out.append("<");
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(EGT);
                             out.append(">");
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOPBRK:
      jj_consume_token(EOPBRK);
                             out.append("[");
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_2;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(ECLBRK);
                             out.append("]");
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
                             out.append("unicode,evaluate:");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANYEXPR:
      token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELT:
        case EGT:
        case EOPBRK:
        case ECLBRK:
        case EQUOTE:
        case ANYEXPR:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ELT:
          jj_consume_token(ELT);
                             out.append("<");
          break;
        case EGT:
          jj_consume_token(EGT);
                             out.append(">");
          break;
        case EOPBRK:
          jj_consume_token(EOPBRK);
                             out.append("[");
          break;
        case ECLBRK:
          jj_consume_token(ECLBRK);
                             out.append("]");
          break;
        case EQUOTE:
          jj_consume_token(EQUOTE);
                             out.append("\"");
          break;
        case ANYEXPR:
          token = jj_consume_token(ANYEXPR);
                             out.append(token.image);
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    jj_consume_token(EXPRE);
                             out.append("*}");
  }

  final public void Line() throws ParseException, IOException {
                                   Token token=null;
    Token();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCAPE:
      case GCBEGIN:
      case GCEND:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case CLSLVL:
      case FLLVL:
      case TCBEGIN:
      case TCEND:
      case JTTBEGIN:
      case JTTEND:
      case MTTBEGIN:
      case MTTEND:
      case TAGBEGIN:
      case TAGEND:
      case INSERT:
      case TPL:
      case ETPL:
      case PART:
      case EPART:
      case MSG:
      case DOCLET:
      case WORK:
      case REGEXP:
      case ECLSLVL:
      case EFLLVL:
      case LNINDT:
      case IGNORE:
      case NULL:
      case TRUE:
      case FALSE:
      case EQUALS:
      case WS:
      case XPATH:
      case PROPERTY:
      case XMODEL:
      case FILE:
      case SQL:
      case OQL:
      case LOCATOR:
      case FOR:
      case EFOR:
      case SELECT:
      case ESELECT:
      case EXISTS:
      case EEXISTS:
      case NOTEXISTS:
      case ENOTEXISTS:
      case ISVALID:
      case EISVALID:
      case ISINVALID:
      case EISINVALID:
      case UNION:
      case ELEMENT:
      case EELEMENT:
      case NOTELEMENT:
      case ENOTELEMENT:
      case CURRENT:
      case INDEXOP:
      case INDEXDECL:
      case INDEX:
      case ADD:
      case REMOVE:
      case CREATE:
      case FIRSTOP:
      case FIRSTDECL:
      case FIRST:
      case NOTFIRSTOP:
      case NOTFIRST:
      case LAST:
      case NOTLAST:
      case EFIRST:
      case ENOTFIRST:
      case ELAST:
      case ENOTLAST:
      case EMPTY:
      case NOTEMPTY:
      case NOT:
      case ELSE:
      case OR:
      case AND:
      case ISA:
      case NOTISA:
      case EINDENT:
      case INDENT:
      case NEWLINE:
      case RECODING:
      case ERECODING:
      case JOIN:
      case EJOIN:
      case CONFIG:
      case DYNAMIC:
      case PLACEHOLDER:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case REVERSE:
      case PERPER:
      case PERCLO:
      case OPEPER:
      case DSHCLO:
      case OPEDSH:
      case EQUCLO:
      case OPEEQU:
      case BACKSL:
      case DELIM:
      case ANY:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                               out.append(token.image);
        break;
      case LNINDT:
        jj_consume_token(LNINDT);
                               out.append(token.image);
        break;
      case ESCAPE:
      case GCBEGIN:
      case GCEND:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case CLSLVL:
      case FLLVL:
      case TCBEGIN:
      case TCEND:
      case JTTBEGIN:
      case JTTEND:
      case MTTBEGIN:
      case MTTEND:
      case TAGBEGIN:
      case TAGEND:
      case INSERT:
      case TPL:
      case ETPL:
      case PART:
      case EPART:
      case MSG:
      case DOCLET:
      case WORK:
      case REGEXP:
      case ECLSLVL:
      case EFLLVL:
      case IGNORE:
      case NULL:
      case TRUE:
      case FALSE:
      case EQUALS:
      case XPATH:
      case PROPERTY:
      case XMODEL:
      case FILE:
      case SQL:
      case OQL:
      case LOCATOR:
      case FOR:
      case EFOR:
      case SELECT:
      case ESELECT:
      case EXISTS:
      case EEXISTS:
      case NOTEXISTS:
      case ENOTEXISTS:
      case ISVALID:
      case EISVALID:
      case ISINVALID:
      case EISINVALID:
      case UNION:
      case ELEMENT:
      case EELEMENT:
      case NOTELEMENT:
      case ENOTELEMENT:
      case CURRENT:
      case INDEXOP:
      case INDEXDECL:
      case INDEX:
      case ADD:
      case REMOVE:
      case CREATE:
      case FIRSTOP:
      case FIRSTDECL:
      case FIRST:
      case NOTFIRSTOP:
      case NOTFIRST:
      case LAST:
      case NOTLAST:
      case EFIRST:
      case ENOTFIRST:
      case ELAST:
      case ENOTLAST:
      case EMPTY:
      case NOTEMPTY:
      case NOT:
      case ELSE:
      case OR:
      case AND:
      case ISA:
      case NOTISA:
      case EINDENT:
      case INDENT:
      case NEWLINE:
      case RECODING:
      case ERECODING:
      case JOIN:
      case EJOIN:
      case CONFIG:
      case DYNAMIC:
      case PLACEHOLDER:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case REVERSE:
      case PERPER:
      case PERCLO:
      case OPEPER:
      case DSHCLO:
      case OPEDSH:
      case EQUCLO:
      case OPEEQU:
      case BACKSL:
      case DELIM:
      case ANY:
        Token();
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void LeadingSpace() throws ParseException, IOException {
                                           Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      token = jj_consume_token(WS);
                             out.append(token.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNINDT:
        jj_consume_token(LNINDT);
                             out.append("<%|");
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          token = jj_consume_token(WS);
                             out.append(token.image);
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      break;
    case LNINDT:
      jj_consume_token(LNINDT);
                             out.append("<%|");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        token = jj_consume_token(WS);
                             out.append(token.image);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NewLine() throws ParseException, IOException {
                                      Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LNCONT:
      jj_consume_token(LNCONT);
                           out.append("\\\n");
      break;
    case LN:
      jj_consume_token(LN);
                           out.append("\n");
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void CUS() throws ParseException, IOException {
                                  Token token=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LNINDT:
    case WS:
      LeadingSpace();
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCAPE:
    case GCBEGIN:
    case GCEND:
    case CMTBEGIN:
    case CMTEND:
    case EXPRBEGIN:
    case EXPREND:
    case CLSLVL:
    case FLLVL:
    case TCBEGIN:
    case TCEND:
    case JTTBEGIN:
    case JTTEND:
    case MTTBEGIN:
    case MTTEND:
    case TAGBEGIN:
    case TAGEND:
    case INSERT:
    case TPL:
    case ETPL:
    case PART:
    case EPART:
    case MSG:
    case DOCLET:
    case WORK:
    case REGEXP:
    case ECLSLVL:
    case EFLLVL:
    case IGNORE:
    case NULL:
    case TRUE:
    case FALSE:
    case EQUALS:
    case XPATH:
    case PROPERTY:
    case XMODEL:
    case FILE:
    case SQL:
    case OQL:
    case LOCATOR:
    case FOR:
    case EFOR:
    case SELECT:
    case ESELECT:
    case EXISTS:
    case EEXISTS:
    case NOTEXISTS:
    case ENOTEXISTS:
    case ISVALID:
    case EISVALID:
    case ISINVALID:
    case EISINVALID:
    case UNION:
    case ELEMENT:
    case EELEMENT:
    case NOTELEMENT:
    case ENOTELEMENT:
    case CURRENT:
    case INDEXOP:
    case INDEXDECL:
    case INDEX:
    case ADD:
    case REMOVE:
    case CREATE:
    case FIRSTOP:
    case FIRSTDECL:
    case FIRST:
    case NOTFIRSTOP:
    case NOTFIRST:
    case LAST:
    case NOTLAST:
    case EFIRST:
    case ENOTFIRST:
    case ELAST:
    case ENOTLAST:
    case EMPTY:
    case NOTEMPTY:
    case NOT:
    case ELSE:
    case OR:
    case AND:
    case ISA:
    case NOTISA:
    case EINDENT:
    case INDENT:
    case NEWLINE:
    case RECODING:
    case ERECODING:
    case JOIN:
    case EJOIN:
    case CONFIG:
    case DYNAMIC:
    case PLACEHOLDER:
    case TIME:
    case FORMAT:
    case SIZE:
    case AVERAGE:
    case PRODUCT:
    case SUM:
    case MINIMUM:
    case MAXIMUM:
    case REVERSE:
    case PERPER:
    case PERCLO:
    case OPEPER:
    case DSHCLO:
    case OPEDSH:
    case EQUCLO:
    case OPEEQU:
    case BACKSL:
    case DELIM:
    case ANY:
      Line();
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNCONT:
      case LN:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_5;
      }
      NewLine();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LNINDT:
      case WS:
        LeadingSpace();
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCAPE:
      case GCBEGIN:
      case GCEND:
      case CMTBEGIN:
      case CMTEND:
      case EXPRBEGIN:
      case EXPREND:
      case CLSLVL:
      case FLLVL:
      case TCBEGIN:
      case TCEND:
      case JTTBEGIN:
      case JTTEND:
      case MTTBEGIN:
      case MTTEND:
      case TAGBEGIN:
      case TAGEND:
      case INSERT:
      case TPL:
      case ETPL:
      case PART:
      case EPART:
      case MSG:
      case DOCLET:
      case WORK:
      case REGEXP:
      case ECLSLVL:
      case EFLLVL:
      case IGNORE:
      case NULL:
      case TRUE:
      case FALSE:
      case EQUALS:
      case XPATH:
      case PROPERTY:
      case XMODEL:
      case FILE:
      case SQL:
      case OQL:
      case LOCATOR:
      case FOR:
      case EFOR:
      case SELECT:
      case ESELECT:
      case EXISTS:
      case EEXISTS:
      case NOTEXISTS:
      case ENOTEXISTS:
      case ISVALID:
      case EISVALID:
      case ISINVALID:
      case EISINVALID:
      case UNION:
      case ELEMENT:
      case EELEMENT:
      case NOTELEMENT:
      case ENOTELEMENT:
      case CURRENT:
      case INDEXOP:
      case INDEXDECL:
      case INDEX:
      case ADD:
      case REMOVE:
      case CREATE:
      case FIRSTOP:
      case FIRSTDECL:
      case FIRST:
      case NOTFIRSTOP:
      case NOTFIRST:
      case LAST:
      case NOTLAST:
      case EFIRST:
      case ENOTFIRST:
      case ELAST:
      case ENOTLAST:
      case EMPTY:
      case NOTEMPTY:
      case NOT:
      case ELSE:
      case OR:
      case AND:
      case ISA:
      case NOTISA:
      case EINDENT:
      case INDENT:
      case NEWLINE:
      case RECODING:
      case ERECODING:
      case JOIN:
      case EJOIN:
      case CONFIG:
      case DYNAMIC:
      case PLACEHOLDER:
      case TIME:
      case FORMAT:
      case SIZE:
      case AVERAGE:
      case PRODUCT:
      case SUM:
      case MINIMUM:
      case MAXIMUM:
      case REVERSE:
      case PERPER:
      case PERCLO:
      case OPEPER:
      case DSHCLO:
      case OPEDSH:
      case EQUCLO:
      case OPEEQU:
      case BACKSL:
      case DELIM:
      case ANY:
        Line();
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    }
    jj_consume_token(0);
  }

  public CUS2ASCIITokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[22];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x7fffffe,0x0,0x0,0x10000000,0x0,0x0,0x40000000,0xf0000000,0xf0000000,0x0,0x7fffffe,0x7fffffe,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffffe,0x0,0x0,0x7fffffe,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0xffffcf98,0x5,0x5,0x0,0x5,0x5,0x0,0x5,0x5,0x4,0xffffdfd8,0xffffdfd8,0x1000,0x40,0x1000,0x1040,0x2020,0x1040,0xffffcf98,0x2020,0x1040,0xffffcf98,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0xffffffff,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x1fffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fffffff,0x1fffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x1fffffff,0x0,0x0,0x1fffffff,};
   }

  public CUS2ASCII(java.io.InputStream stream) {
     this(stream, null);
  }
  public CUS2ASCII(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CUS2ASCIITokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public CUS2ASCII(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CUS2ASCIITokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public CUS2ASCII(CUS2ASCIITokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(CUS2ASCIITokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[125];
    for (int i = 0; i < 125; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 22; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 125; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
