/* Generated By:JavaCC: Do not edit this line. Tag.java */

/****************************************************************************
  Copyright 2001-2018 Sphenon GmbH

  Licensed under the Apache License, Version 2.0 (the "License"); you may not
  use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
  License for the specific language governing permissions and limitations
  under the License.
*****************************************************************************/
package com.sphenon.engines.generator.tchandler.classes;

import com.sphenon.basics.context.*;
import com.sphenon.engines.generator.*;
import com.sphenon.engines.generator.tom.*;
import com.sphenon.engines.generator.tchandler.*;
import com.sphenon.engines.generator.returncodes.*;

import java.io.Reader;
import java.io.Writer;
import java.io.IOException;

import java.util.Vector;

public class Tag implements TagConstants {

  protected Writer    out;
  protected TCHTag    tch;
  protected TCHPPTag  tchpp;
  protected TCEvent   event;

  public Tag (CallContext context, Reader in, TCHTag tch, TCEvent event) {
      this(in);
      this.out   = out;
      this.tch   = tch;
      this.event = event;
  }

  public Tag (CallContext context, Reader in, TCHPPTag tchpp, TCEvent event) {
      this(in);
      this.out   = out;
      this.tchpp = tchpp;
      this.event = event;
  }

  public String getPosition(CallContext context) {
      return   "[line "    + jj_input_stream.getBeginLine()
                           + (jj_input_stream.getBeginLine() != jj_input_stream.getEndLine() ? ("-" + jj_input_stream.getEndLine()) : "")
             + ", column " + jj_input_stream.getBeginColumn()
                           + (jj_input_stream.getBeginColumn() != jj_input_stream.getEndColumn() ? ("-" + jj_input_stream.getEndColumn()) : "")
             + "]";
  }

  final public void Block(CallContext context, StringBuffer value) throws ParseException {
                                                        Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      token = jj_consume_token(OPPAR);
                          value.append(token.image);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case COMMA:
        case COLON:
        case EQUAL:
        case DOT:
        case SLASH:
        case ASTERISK:
        case ANY:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        JavaCodeBalanced(context, value);
      }
      token = jj_consume_token(CLPAR);
                          value.append(token.image);
      break;
    case OPBRC:
      token = jj_consume_token(OPBRC);
                          value.append(token.image);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case COMMA:
        case COLON:
        case EQUAL:
        case DOT:
        case SLASH:
        case ASTERISK:
        case ANY:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        JavaCodeBalanced(context, value);
      }
      token = jj_consume_token(CLBRC);
                          value.append(token.image);
      break;
    case OPBRK:
      token = jj_consume_token(OPBRK);
                          value.append(token.image);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case OPPAR:
        case OPBRC:
        case OPBRK:
        case COMMA:
        case COLON:
        case EQUAL:
        case DOT:
        case SLASH:
        case ASTERISK:
        case ANY:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_3;
        }
        JavaCodeBalanced(context, value);
      }
      token = jj_consume_token(CLBRK);
                          value.append(token.image);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void TokensButComma(CallContext context, StringBuffer value) throws ParseException {
                                                                 Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
      token = jj_consume_token(CHARACTER_LITERAL);
                                  value.append(token.image);
      break;
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
                                  value.append(token.image);
      break;
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
                                  value.append(token.image);
      break;
    case COLON:
      token = jj_consume_token(COLON);
                                  value.append(token.image);
      break;
    case EQUAL:
      token = jj_consume_token(EQUAL);
                                  value.append(token.image);
      break;
    case DOT:
      token = jj_consume_token(DOT);
                                  value.append(token.image);
      break;
    case SLASH:
      token = jj_consume_token(SLASH);
                                  value.append(token.image);
      break;
    case ASTERISK:
      token = jj_consume_token(ASTERISK);
                                  value.append(token.image);
      break;
    case ANY:
      token = jj_consume_token(ANY);
                                  value.append(token.image);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Tokens(CallContext context, StringBuffer value) throws ParseException {
                                                         Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case COLON:
    case EQUAL:
    case DOT:
    case SLASH:
    case ASTERISK:
    case ANY:
      TokensButComma(context, value);
      break;
    case COMMA:
      token = jj_consume_token(COMMA);
                                  value.append(token.image);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void JavaCodeBalanced(CallContext context, StringBuffer value) throws ParseException {
                                                                   Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
    case OPBRC:
    case OPBRK:
      Block(context, value);
      break;
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case COMMA:
    case COLON:
    case EQUAL:
    case DOT:
    case SLASH:
    case ASTERISK:
    case ANY:
      Tokens(context, value);
      break;
    case WS:
      token = jj_consume_token(WS);
                   value.append(token.image);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void JavaCodeBalancedButComma(CallContext context, StringBuffer value) throws ParseException {
                                                                           Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
    case OPBRC:
    case OPBRK:
      Block(context, value);
      break;
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case COLON:
    case EQUAL:
    case DOT:
    case SLASH:
    case ASTERISK:
    case ANY:
      TokensButComma(context, value);
      break;
    case WS:
      token = jj_consume_token(WS);
                   value.append(token.image);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void JavaCodeBalancedButCommaWS(CallContext context, StringBuffer value) throws ParseException {
                                                                             Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
    case OPBRC:
    case OPBRK:
      Block(context, value);
      break;
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case COLON:
    case EQUAL:
    case DOT:
    case SLASH:
    case ASTERISK:
    case ANY:
      TokensButComma(context, value);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String DotIdentifier() throws ParseException {
                           Token token; String result; String postfix;
    postfix = "";
    jj_consume_token(DOT);
    token = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      postfix = DotIdentifier();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
                                                              result = "." + token.image + postfix;
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String DottedIdentifier() throws ParseException {
                              Token token; String result; String postfix;
    postfix = "";
    token = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      postfix = DotIdentifier();
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
                                                        result = token.image + postfix;
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void Argument(CallContext context, StringBuffer value) throws ParseException {
                                                           Token wst = null; String ws = null;
    label_4:
    while (true) {
      if (ws != null) { value.append(ws); ws = null; }
      JavaCodeBalancedButCommaWS(context, value);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        wst = jj_consume_token(WS);
                 ws = wst.image;
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case OPPAR:
      case OPBRC:
      case OPBRK:
      case COLON:
      case EQUAL:
      case DOT:
      case SLASH:
      case ASTERISK:
      case ANY:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_4;
      }
    }
  }

  final public void Arguments(CallContext context, Vector result) throws ParseException {
                                                       StringBuffer value; Token wst = null; String ws = null;
    value = new StringBuffer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case OPPAR:
    case OPBRC:
    case OPBRK:
    case COLON:
    case EQUAL:
    case DOT:
    case SLASH:
    case ASTERISK:
    case ANY:
      Argument(context, value);
                                   result.add(value.toString());
      break;
    default:
      jj_la1[13] = jj_gen;
                                   result.add("");
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      Arguments(context, result);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
  }

  final public TOMNode Invocation(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                               Token tag_name; Token slash=null;
    Vector arguments = new Vector();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH:
      slash = jj_consume_token(SLASH);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    tag_name = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPPAR:
      jj_consume_token(OPPAR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      Arguments(context, arguments);
      jj_consume_token(CLPAR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        jj_consume_token(WS);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    if (tchpp != null) {
        tchpp.handleInvocation(context, event, current_node, tag_name.image, arguments, slash == null);
        {if (true) return null;}
    } else {
        {if (true) return tch.handleInvocation(context, event, current_node, tag_name.image, arguments, slash == null);}
    }
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Declaration(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                                Token tag_name;
    String tch_class;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tag_name = jj_consume_token(IDENTIFIER);
      break;
    case ASTERISK:
      tag_name = jj_consume_token(ASTERISK);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    tch_class = DottedIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    if (tchpp != null) {
        tchpp.handleDeclaration(context, event, current_node, tag_name.image, tch_class);
        {if (true) return null;}
    } else {
        {if (true) return tch.handleDeclaration(context, event, current_node, tag_name.image, tch_class);}
    }
    throw new Error("Missing return statement in function");
  }

  final public TOMNode Tag(CallContext context, TOMNode current_node) throws ParseException, InvalidTemplateSyntax {
                                                                                         Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
      jj_consume_token(WS);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    if (jj_2_1(2147483647)) {
      current_node = Declaration(context, current_node);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case SLASH:
        current_node = Invocation(context, current_node);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
    {if (true) return current_node;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(1)) jj_scanpos = xsp;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  public TagTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[28];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x3fabe,0x3fabe,0x3fabe,0x2a0,0x3f01c,0x3f81c,0x3fabe,0x3f2be,0x3f2bc,0x4000,0x4000,0x2,0x3f2bc,0x3f2bc,0x2,0x800,0x2,0x8000,0x2,0x2,0x2,0x20,0x10010,0x2,0x2,0x2,0x2,0x8010,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public Tag(java.io.InputStream stream) {
     this(stream, null);
  }
  public Tag(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TagTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Tag(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TagTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Tag(TagTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(TagTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[18];
    for (int i = 0; i < 18; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 28; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 18; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
